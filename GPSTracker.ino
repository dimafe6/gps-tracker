#define FAKE_GPS;
#define NMEA "$GPRMC,192631,A,5025.072260,N,03026.522160,E,5.4,24.7,170518,,,A*42\r\n$GPGGA,192631,5025.072260,N,03026.522160,E,1,12,0.78,3.0,M,0.0,M,,*45\r\n$GPGLL,5025.072260,N,03026.522160,E,192631,A,A*4F\r\n$GPZDA,192631,17,05,2018,,*4E\r\n$GPGSA,A,3,07,25,16,01,18,22,26,30,08,47,24,06,1.32,0.78,1.07*08\r\n$GPGSV,3,1,12,07,90,0,44,25,30,240,40,16,30,120,40,01,30,0,40*75\r\n$GPGSV,3,2,12,18,59,203,42,22,59,278,40,26,15,108,40,30,49,183,41*70\r\n$GPGSV,3,3,12,08,35,057,49,47,32,125,46,24,20,152,47,06,16,274,42*7A\r\n$GPRMC,192641,A,5025.085880,N,03026.531982,E,5.4,24.7,170518,,,A*4F\r\n$GPGGA,192641,5025.085880,N,03026.531982,E,1,12,0.78,3.0,M,0.0,M,,*48\r\n$GPGLL,5025.085880,N,03026.531982,E,192641,A,A*42\r\n$GPZDA,192641,17,05,2018,,*49\r\n$GPRMC,192651,A,5025.099499,N,03026.541803,E,5.4,24.7,170518,,,A*48\r\n$GPGGA,192651,5025.099499,N,03026.541803,E,1,12,0.78,3.0,M,0.0,M,,*4F\r\n$GPGLL,5025.099499,N,03026.541803,E,192651,A,A*45\r\n$GPZDA,192651,17,05,2018,,*48\r\n$GPRMC,192701,A,5025.113119,N,03026.551625,E,5.4,24.7,170518,,,A*49\r\n$GPGGA,192701,5025.113119,N,03026.551625,E,1,12,0.78,3.0,M,0.0,M,,*4E\r\n$GPGLL,5025.113119,N,03026.551625,E,192701,A,A*44\r\n$GPZDA,192701,17,05,2018,,*4C\r\n$GPGSA,A,3,07,25,16,01,18,22,26,30,08,47,24,06,1.32,0.78,1.07*08\r\n$GPGSV,3,1,12,07,90,0,44,25,30,240,40,16,30,120,40,01,30,0,40*75\r\n$GPGSV,3,2,12,18,59,203,42,22,59,278,40,26,15,108,40,30,49,183,41*70\r\n$GPGSV,3,3,12,08,35,057,49,47,32,125,46,24,20,152,47,06,16,274,42*7A\r\n$GPRMC,192711,A,5025.126739,N,03026.561447,E,5.4,24.7,170518,,,A*4F\r\n$GPGGA,192711,5025.126739,N,03026.561447,E,1,12,0.78,3.0,M,0.0,M,,*48\r\n$GPGLL,5025.126739,N,03026.561447,E,192711,A,A*42\r\n$GPZDA,192711,17,05,2018,,*4D\r\n$GPRMC,192721,A,5025.140358,N,03026.571269,E,5.4,24.7,170518,,,A*44\r\n$GPGGA,192721,5025.140358,N,03026.571269,E,1,12,0.78,3.0,M,0.0,M,,*43\r\n$GPGLL,5025.140358,N,03026.571269,E,192721,A,A*49\r\n$GPZDA,192721,17,05,2018,,*4E\r\n$GPRMC,192731,A,5025.153978,N,03026.581091,E,5.4,24.7,170518,,,A*45\r\n$GPGGA,192731,5025.153978,N,03026.581091,E,1,12,0.78,3.0,M,0.0,M,,*42\r\n$GPGLL,5025.153978,N,03026.581091,E,192731,A,A*48\r\n$GPZDA,192731,17,05,2018,,*4F\r\n$GPGSA,A,3,07,25,16,01,18,22,26,30,08,47,24,06,1.32,0.78,1.07*08\r\n$GPGSV,3,1,12,07,90,0,44,25,30,240,40,16,30,120,40,01,30,0,40*75\r\n$GPGSV,3,2,12,18,59,203,42,22,59,278,40,26,15,108,40,30,49,183,41*70\r\n$GPGSV,3,3,12,08,35,057,49,47,32,125,46,24,20,152,47,06,16,274,42*7A\r\n$GPRMC,192741,A,5025.167597,N,03026.590914,E,5.4,24.7,170518,,,A*4C\r\n$GPGGA,192741,5025.167597,N,03026.590914,E,1,12,0.78,3.0,M,0.0,M,,*4B\r\n$GPGLL,5025.167597,N,03026.590914,E,192741,A,A*41\r\n$GPZDA,192741,17,05,2018,,*48\r\n$GPRMC,192751,A,5025.181217,N,03026.600736,E,5.4,24.7,170518,,,A*4E\r\n$GPGGA,192751,5025.181217,N,03026.600736,E,1,12,0.78,3.0,M,0.0,M,,*49\r\n$GPGLL,5025.181217,N,03026.600736,E,192751,A,A*43\r\n$GPZDA,192751,17,05,2018,,*49\r\n$GPRMC,192801,A,5025.194836,N,03026.610558,E,5.4,24.7,170518,,,A*42\r\n$GPGGA,192801,5025.194836,N,03026.610558,E,1,12,0.78,3.0,M,0.0,M,,*45\r\n$GPGLL,5025.194836,N,03026.610558,E,192801,A,A*4F\r\n$GPZDA,192801,17,05,2018,,*43\r\n$GPGSA,A,3,07,25,16,01,18,22,26,30,08,47,24,06,1.32,0.78,1.07*08\r\n$GPGSV,3,1,12,07,90,0,44,25,30,240,40,16,30,120,40,01,30,0,40*75\r\n$GPGSV,3,2,12,18,59,203,42,22,59,278,40,26,15,108,40,30,49,183,41*70\r\n$GPGSV,3,3,12,08,35,057,49,47,32,125,46,24,20,152,47,06,16,274,42*7A\r\n$GPRMC,192811,A,5025.208456,N,03026.620381,E,5.4,24.7,170518,,,A*4E\r\n$GPGGA,192811,5025.208456,N,03026.620381,E,1,12,0.78,3.0,M,0.0,M,,*49\r\n$GPGLL,5025.208456,N,03026.620381,E,192811,A,A*43\r\n$GPZDA,192811,17,05,2018,,*42\r\n$GPRMC,192821,A,5025.222075,N,03026.630203,E,5.4,24.7,170518,,,A*4A\r\n$GPGGA,192821,5025.222075,N,03026.630203,E,1,12,0.78,3.0,M,0.0,M,,*4D\r\n$GPGLL,5025.222075,N,03026.630203,E,192821,A,A*47\r\n$GPZDA,192821,17,05,2018,,*41\r\n$GPRMC,192831,A,5025.235695,N,03026.640026,E,5.4,24.7,170518,,,A*47\r\n$GPGGA,192831,5025.235695,N,03026.640026,E,1,12,0.78,3.0,M,0.0,M,,*40\r\n$GPGLL,5025.235695,N,03026.640026,E,192831,A,A*4A\r\n$GPZDA,192831,17,05,2018,,*40\r\n$GPGSA,A,3,07,25,16,01,18,22,26,30,08,47,24,06,1.32,0.78,1.07*08\r\n$GPGSV,3,1,12,07,90,0,44,25,30,240,40,16,30,120,40,01,30,0,40*75\r\n$GPGSV,3,2,12,18,59,203,42,22,59,278,40,26,15,108,40,30,49,183,41*70\r\n$GPGSV,3,3,12,08,35,057,49,47,32,125,46,24,20,152,47,06,16,274,42*7A\r\n$GPRMC,192841,A,5025.249314,N,03026.649849,E,5.4,24.7,170518,,,A*4F\r\n$GPGGA,192841,5025.249314,N,03026.649849,E,1,12,0.78,3.0,M,0.0,M,,*48\r\n$GPGLL,5025.249314,N,03026.649849,E,192841,A,A*42\r\n$GPZDA,192841,17,05,2018,,*47\r\n$GPRMC,192851,A,5025.262934,N,03026.659672,E,5.4,24.7,170518,,,A*48\r\n$GPGGA,192851,5025.262934,N,03026.659672,E,1,12,0.78,3.0,M,0.0,M,,*4F\r\n$GPGLL,5025.262934,N,03026.659672,E,192851,A,A*45\r\n$GPZDA,192851,17,05,2018,,*46\r\n$GPRMC,192901,A,5025.276553,N,03026.669495,E,5.4,24.7,170518,,,A*4C\r\n$GPGGA,192901,5025.276553,N,03026.669495,E,1,12,0.78,3.0,M,0.0,M,,*4B\r\n$GPGLL,5025.276553,N,03026.669495,E,192901,A,A*41\r\n$GPZDA,192901,17,05,2018,,*42\r\n$GPGSA,A,3,07,25,16,01,18,22,26,30,08,47,24,06,1.32,0.78,1.07*08\r\n$GPGSV,3,1,12,07,90,0,44,25,30,240,40,16,30,120,40,01,30,0,40*75\r\n$GPGSV,3,2,12,18,59,203,42,22,59,278,40,26,15,108,40,30,49,183,41*70\r\n$GPGSV,3,3,12,08,35,057,49,47,32,125,46,24,20,152,47,06,16,274,42*7A\r\n$GPRMC,192911,A,5025.290173,N,03026.679318,E,5.4,24.7,170518,,,A*40\r\n$GPGGA,192911,5025.290173,N,03026.679318,E,1,12,0.78,3.0,M,0.0,M,,*47\r\n$GPGLL,5025.290173,N,03026.679318,E,192911,A,A*4D\r\n$GPZDA,192911,17,05,2018,,*43\r\n"
#define BLYNK_PRINT Serial


#include <ESP8266WiFi.h>
#include <BlynkSimpleEsp8266.h>
#include <SimpleTimer.h>
#include <ESP8266WiFi.h>
#include <TinyGPS++.h>
#include <SoftwareSerial.h>
#include <SPI.h>
#include <SD.h>
#include <ArduinoJson.h>

extern "C" {
	#include "user_interface.h"
}

#ifdef FAKE_GPS
String nmeaBuff = NMEA;
int nmeaIndex = 0;
#endif

static const int RXPin = D1, TXPin = SW_SERIAL_UNUSED_PIN;
static const uint32_t GPSBaud = 9600;
const int chipSelect = D2;
const int powerSwitchPin = 10;

char auth[] = "a1436b98817c426ea91740829e164a3f";
//char ssid[] = "VirtualRouter.codeplex.com";
//char ssid[] = "Zenfone4";
//char pass[] = "12345678";
char ssid[] = "dimaPC";
char pass[] = "I0U5cRX3";

unsigned long startGPSFindTime = millis();
int WiFiConnectionTimer;
int blynkConnectionTimer;
int gpsTimer;
unsigned int wifiConnectionRetries;
unsigned int blynkConnectionRetries;
String newTrackName = "";

SimpleTimer timer;
WidgetMap myMap(V0);
TinyGPSPlus gps;
SoftwareSerial ss(RXPin, TXPin);
File root;

struct Config {
  float prevLatitude = 0;
  float prevLongitude = 0;
  unsigned int gpsSearchTime = 5000;
  unsigned long sleepTime = 2e6;
  unsigned int wifiConnectionTimeout = 100;
  unsigned int wifiConnectionRetries = 50;
  unsigned int blynkConnectionTimeout = 100;
  unsigned int blynkConnectionRetries = 50;
  String currentTrackName = "track0.gps";
  bool trackPaused = false;
  unsigned int frequencyWaypoints = 100;
  String sleepType = "MANUAL";
  unsigned int lastMapPointIndex = 1;
};

const char *configFilename = "CONFIG.TXT";
Config config;

void setup() {
	WiFi.persistent( false );

  pinMode(RXPin, INPUT);
  pinMode(powerSwitchPin, OUTPUT);
  digitalWrite(powerSwitchPin, HIGH);

  Serial.begin(115200);

  ss.begin(GPSBaud);
  ss.enableIntTx(false);

  initSDCard();
  
  initWiFi();

  checkTraveledDistance();
}

void loop() {
  Blynk.run();
  timer.run();
}

void initSDCard() {
  Serial.println("");
  Serial.print("Initializing SD card...");

  if (!SD.begin(chipSelect)) {
    Serial.println("Card failed, or not present");
    sleep();
  }

  Serial.println("card initialized.");

  // Load last saved configuration
  loadConfiguration(configFilename, config);  

  if (!SD.exists(getTrackFileName()))
  {
  	Serial.println("Creating new track file " + getTrackFileName());
    File dataFile = SD.open(getTrackFileName(), FILE_WRITE);
    dataFile.println(F("type, satellites, hdop, latitude, longitude, age, date, alt, course, speed, name, desc"));
    dataFile.close();
  }
}

void initWiFi() {
  Serial.println("");

  Serial.println("Connecting to WIFI");
  WiFi.begin(ssid, pass);

  wifiConnectionRetries = config.wifiConnectionRetries;
	WiFiConnectionTimer = timer.setInterval(config.wifiConnectionTimeout, checkWiFiConnect);
}

void checkWiFiConnect() {
  if (WiFi.status() != WL_CONNECTED && wifiConnectionRetries <= 0) {
    onWiFiConnectionTimeout();

    return;
  }

  if (WiFi.status() == WL_CONNECTED) {
    onWiFiConnected();

    return;
  }

  wifiConnectionRetries--;
}

void onWiFiConnected() {
  	timer.deleteTimer(WiFiConnectionTimer);

    Serial.println("WiFi connected");
    Serial.print("IP address: ");Serial.println(WiFi.localIP());
    
    Blynk.config(auth);
    Blynk.connect();

    blynkConnectionRetries = config.blynkConnectionRetries;
    blynkConnectionTimer = timer.setInterval(config.blynkConnectionTimeout, checkBlynkConnect);
}

void checkBlynkConnect() {
  if (!Blynk.connected() && blynkConnectionRetries <= 0) {
    onBlynkConnectionTimeout();

    return;
  }

  if (Blynk.connected()) {
    onBlynkConnected();

		return;
  }

  blynkConnectionRetries--;
}

void onBlynkConnectionTimeout() {
  timer.deleteTimer(blynkConnectionTimer);

  Serial.println("Blynk connection timeout.");
  
  offlineMode();
  runGPSTimer();
}

void onBlynkConnected() {
  timer.deleteTimer(blynkConnectionTimer);

  Serial.println("Blynk server connected");
  
    runGPSTimer();
}

void onWiFiConnectionTimeout() {
  timer.deleteTimer(WiFiConnectionTimer);
  offlineMode();
  runGPSTimer();
  Serial.println("");
}

void loadConfiguration(JsonObject &root, Config &config) {
  config.prevLatitude = root["prevLatitude"] | config.prevLatitude;
  config.prevLongitude = root["prevLongitude"] | config.prevLongitude;
  config.gpsSearchTime = root["gpsSearchTime"] | config.gpsSearchTime;
  config.sleepTime = root["sleepTime"] | config.sleepTime;
  config.wifiConnectionTimeout = root["wifiConnectionTimeout"] | config.wifiConnectionTimeout;
  config.wifiConnectionRetries = root["wifiConnectionRetries"] | config.wifiConnectionRetries;
  config.blynkConnectionTimeout = root["blynkConnectionTimeout"] | config.blynkConnectionTimeout;
  config.blynkConnectionRetries = root["blynkConnectionRetries"] | config.blynkConnectionRetries;
  String currentTrackName = root["currentTrackName"].as<String>();
  config.currentTrackName = currentTrackName == "" ? config.currentTrackName : currentTrackName;
  config.trackPaused = root["trackPaused"] == 1 ? true : false;
  config.frequencyWaypoints = root["frequencyWaypoints"] | config.frequencyWaypoints;
  String sleepType = root["sleepType"].as<String>();
  config.sleepType = sleepType == "" ? config.sleepType : sleepType;
  config.lastMapPointIndex = root["lastMapPointIndex"] | config.lastMapPointIndex;

  root.printTo(Serial);
}

void loadConfiguration(const char *filename, Config &config) {
  Serial.println("Loading configuration from SD...");

  File file = SD.open(filename);

  // Allocate the memory pool on the stack.
  // Don't forget to change the capacity to match your JSON document.
  // Use arduinojson.org/assistant to compute the capacity.
  StaticJsonBuffer<1024> jsonBuffer;

  JsonObject &root = jsonBuffer.parseObject(file);

  if (!root.success()) {
    Serial.println(F("Failed to read file, using default configuration"));
  }

  loadConfiguration(root, config);
  
  file.close();
}

// Saves the configuration to a file
void saveConfiguration(const char *filename, const Config &config) {
  Serial.println("");
  Serial.println("Saving configuration...");
  Serial.print("Removing configuration file ");Serial.print(filename);Serial.print(" ...");
  
  if(SD.remove(filename)) {
    Serial.println("OK");

    File file = SD.open(filename, FILE_WRITE);
    if (!file) {
      Serial.println(F("Failed to create file"));
      return;
    }

    StaticJsonBuffer<1024> jsonBuffer;

    JsonObject &root = jsonBuffer.createObject();

    root["prevLatitude"] = config.prevLatitude;
    root["prevLongitude"] = config.prevLongitude;
    root["gpsSearchTime"] = config.gpsSearchTime;
    root["sleepTime"] = config.sleepTime;
    root["wifiConnectionTimeout"] = config.wifiConnectionTimeout;
    root["wifiConnectionRetries"] = config.wifiConnectionRetries;
    root["blynkConnectionTimeout"] = config.blynkConnectionTimeout;
    root["blynkConnectionRetries"] = config.blynkConnectionRetries;
    root["currentTrackName"] = config.currentTrackName;
    root["trackPaused"] = config.trackPaused ? 1 : 0;
    root["frequencyWaypoints"] = config.frequencyWaypoints;
    root["sleepType"] = config.sleepType;
    root["lastMapPointIndex"] = config.lastMapPointIndex;

    if (root.printTo(file) == 0) {
      Serial.println(F("Failed to write to file"));
    } else {
      String settings;
      root.printTo(settings);
    }

    root.printTo(Serial);

    file.close();
  } else {
    Serial.println(F("Failed to remove file"));
  }
}

void offlineMode() {
  Serial.println("Offline mode");
  wifi_set_sleep_type(MODEM_SLEEP_T);
  delay(1);
}

void runGPSTimer() {
  Serial.println("Waiting for GPS data...");
  timer.deleteTimer(gpsTimer);
  startGPSFindTime = millis();
  gpsTimer = timer.setInterval(0.01, processGPSData);
}

void sleep() {
  saveConfiguration(configFilename, config);

	if(config.sleepTime > 0) {
		Serial.println("");
		Serial.println("Sleeping...");

		ESP.deepSleep(config.sleepTime, WAKE_RF_DEFAULT);
	}
}

void processGPSData() {
  String content = "";
  char character;
  unsigned long currentSearchTime =  millis() - startGPSFindTime;

  if (config.trackPaused) {
    Serial.println("Track paused.");
    sleep();
  }

  #ifdef FAKE_GPS
  	int i = 0;

  	if(nmeaIndex+2 >= nmeaBuff.length()) {
  		nmeaIndex = 0;
  	}

    if(nmeaIndex < 0) {
      nmeaIndex = 0;
    }
   
		for(i = nmeaIndex; i < nmeaBuff.length(); i++) {
			character = nmeaBuff[i];
	    content.concat(character);
	    if (gps.encode(character)) {
        if(gps.location.lat() == config.prevLatitude && gps.location.lng() == config.prevLongitude) {
          continue;
        }
        
	    	nmeaIndex = i;
	      displayInfo();
	    }
	  }
  #else
	  while (ss.available() && currentSearchTime <= config.gpsSearchTime && config.trackPaused == false) {
	    character = ss.read();
	    content.concat(character);
	    if (gps.encode(character)) {
	      displayInfo();
	    }
	  }
  #endif

  if ( currentSearchTime > config.gpsSearchTime) {
    Serial.println("GPS fix not found.");
    sleep();
  }
}

void displayInfo() {
  if (fixFound())
  {
    float latitude = gps.location.lat();
    float longitude = gps.location.lng();
    float speedMps = gps.speed.mps();
    float alt = gps.altitude.meters();
    int sats = gps.satellites.value();

    if(checkTraveledDistance()) {
      Serial.print("LAT:  ");
      Serial.println(latitude, 6);
      Serial.print("LONG: ");
      Serial.println(longitude, 6);
      Serial.print("SPEED: ");
      Serial.println(speedMps, 2);
      Serial.print("ALT: ");
      Serial.println(alt, 2);
      Serial.print("SATS: ");
      Serial.println(sats, 1);
    
      char date[32];
      sprintf(date, "%02d-%02d-%02d %02d:%02d:%02d ", gps.date.month(), gps.date.day(), gps.date.year(),  gps.time.hour(),  gps.time.minute(),  gps.time.second());

      myMap.location(config.lastMapPointIndex++, latitude, longitude, date);

      config.prevLatitude = latitude;
      config.prevLongitude = longitude;

      writeToSD();
      sleep();
    }
  }
}

String getTrackFileName() {
	return config.currentTrackName;
}

bool fixFound() {
	return gps.location.isValid() && gps.speed.isValid() && gps.date.isValid();
}

float calculateMaxIddleTime() {
	return ((config.gpsSearchTime + (config.wifiConnectionTimeout * config.wifiConnectionRetries)) / 1000) + (config.sleepTime / 1000000); //Seconds.
}

bool checkTraveledDistance() {
	if(!fixFound()) {
		return false;
	}

	if(config.prevLatitude == 0 && config.prevLongitude == 0) {
		config.prevLatitude = gps.location.lat();
		config.prevLongitude = gps.location.lng();
	}

  float speed = ceil(gps.speed.mps());
  unsigned long distance = TinyGPSPlus::distanceBetween(config.prevLatitude, config.prevLongitude, gps.location.lat(), gps.location.lng()); //Meters

  if(speed > 1 && config.sleepType == "AUTO") {
		int newSleepTime = ceil(config.frequencyWaypoints / speed);
		config.sleepTime = newSleepTime <= 2 ? 2e6 : newSleepTime * 1000000;
		Serial.println("New sleep time is: " + String(newSleepTime));
  }

  Serial.println("Traveled distance from previous point: " + String(distance));

  //3000 - higher limit when GPS transferred wrong coordinates
  return (distance >= config.frequencyWaypoints)  && (distance <= 3000);
}

void writeToSD() {
	char sz[32];
	sprintf(sz, "%02d-%02d-%02d %02d:%02d:%02d ", gps.date.month(), gps.date.day(), gps.date.year(),  gps.time.hour(),  gps.time.minute(),  gps.time.second());
	File dataFile = SD.open(getTrackFileName(), FILE_WRITE);

	Serial.println();

	dataFile.print("T");dataFile.print(",");
	dataFile.print((!gps.satellites.isValid()) ? 0 : gps.satellites.value()); dataFile.print(",");
	dataFile.print(!gps.hdop.isValid() ? 0 : gps.hdop.value()); dataFile.print(",");
	dataFile.print(!gps.location.isValid() ? 0 : gps.location.lat(), 6); dataFile.print(",");
	dataFile.print(!gps.location.isValid() ? 0 : gps.location.lng(), 6); dataFile.print(",");
	dataFile.print(!gps.location.isValid() ? 0 : gps.location.age()); dataFile.print(",");

	if (!gps.date.isValid() && !gps.time.isValid()) {
	  dataFile.print("0");
	} else {
	  dataFile.print(sz);
	}
	dataFile.print(",");

	dataFile.print(!gps.altitude.isValid() ? 0 : gps.altitude.meters()); dataFile.print(",");
	dataFile.print(!gps.course.isValid() ? 0 : gps.course.deg()); dataFile.print(",");
	dataFile.print(!gps.speed.kmph() ? 0 : gps.speed.kmph(), 2);
	dataFile.print(","); //name
	dataFile.print(","); //desc

	dataFile.println();
	dataFile.flush();
	dataFile.close();
}

BLYNK_CONNECTED() {
  Blynk.syncAll();
  Blynk.virtualWrite(V7, getTrackFileName());
}

BLYNK_WRITE(V1) {
  config.gpsSearchTime = param.asInt() * 1000; 
}

BLYNK_WRITE(V2) {
  config.sleepTime = param.asInt() * 1000 * 1000; 
}

BLYNK_WRITE(V3){
  config.wifiConnectionTimeout = param.asInt(); 
}

BLYNK_WRITE(V4){
  config.wifiConnectionRetries = param.asInt(); 
}

BLYNK_WRITE(V5){
  config.blynkConnectionTimeout = param.asInt(); 
}

BLYNK_WRITE(V6){
  config.blynkConnectionRetries = param.asInt(); 
}

BLYNK_WRITE(V8){
  bool newState = param.asInt() == 1;

  if(newState != config.trackPaused) {
    if(newState) {
      Blynk.notify("Current track paused");
    } else {
      Blynk.notify("Current track resumed");
    }
  }
  config.trackPaused = newState;
}

BLYNK_WRITE(V9){
  config.frequencyWaypoints = param.asInt(); 
}

BLYNK_WRITE(V10){
  switch(param.asInt()) {
    case 1:
      config.sleepType = "AUTO";
      break;
    case 2:
      config.sleepType = "MANUAL";
      break;
    default:
      config.sleepType = "MANUAL";
      break;
  }
}

BLYNK_WRITE(V11){
  if(param.asInt() == 1) {
    myMap.clear();
    Blynk.virtualWrite(V11, 0);
  }
}

BLYNK_WRITE(V12){
  if(param.asInt() == 1 && newTrackName != "") {
    if(SD.exists(newTrackName)) {
      SD.remove(newTrackName);
    }

    config.currentTrackName = newTrackName + ".gps";
    config.prevLatitude = 0;
    config.prevLongitude = 0;
    config.trackPaused = 0;
    config.lastMapPointIndex = 0;
    
    Blynk.virtualWrite(V7, getTrackFileName());
    Blynk.notify("Started new track " + getTrackFileName());
    myMap.clear();


    Blynk.virtualWrite(V12, 0);

    newTrackName = "";

    saveConfiguration(configFilename, config);
  }
}

BLYNK_WRITE(V13){
  newTrackName = param.asString();  
}